# Judge API Reference

## Overview

The Judge is Aethel's core verification engine. It analyzes programs, verifies constraints, checks conservation laws, and generates mathematical proofs.

## Installation

```python
from diotec360.core.judge import Judge
```

## Class: Judge

### Constructor

```python
Judge(config: Optional[JudgeConfig] = None)
```

Creates a new Judge instance.

**Parameters:**
- `config` (JudgeConfig, optional): Configuration options for the Judge

**Example:**
```python
from diotec360.core.judge import Judge, JudgeConfig

config = JudgeConfig(
    strict_mode=True,
    enable_proofs=True,
    timeout=30
)
judge = Judge(config)
```

### Methods

#### judge.verify()

```python
verify(program: str) -> VerificationResult
```

Verifies an Aethel program and returns the result.

**Parameters:**
- `program` (str): Aethel source code as a string

**Returns:**
- `VerificationResult`: Object containing verification status, proofs, and errors

**Example:**
```python
program = """
solve transfer {
    alice = 1000
    bob = 500
    
    alice = alice - 100
    bob = bob + 100
    
    conserve alice + bob == 1500
}
"""

result = judge.verify(program)
if result.is_valid:
    print("✓ Program verified")
    print(f"Proof: {result.proof}")
else:
    print("✗ Verification failed")
    for error in result.errors:
        print(f"  {error}")
```

#### judge.verify_file()

```python
verify_file(filepath: str) -> VerificationResult
```

Verifies an Aethel program from a file.

**Parameters:**
- `filepath` (str): Path to .ae file

**Returns:**
- `VerificationResult`: Verification result

**Example:**
```python
result = judge.verify_file("safe_transfer.ae")
```

#### judge.get_proof()

```python
get_proof(program: str) -> Proof
```

Generates a detailed mathematical proof for a program.

**Parameters:**
- `program` (str): Aethel source code

**Returns:**
- `Proof`: Detailed proof object

**Example:**
```python
proof = judge.get_proof(program)
print(f"Proof steps: {len(proof.steps)}")
print(f"Theorem: {proof.theorem}")
```

#### judge.check_conservation()

```python
check_conservation(
    program: str,
    variables: List[str]
) -> ConservationResult
```

Checks if conservation laws hold for specified variables.

**Parameters:**
- `program` (str): Aethel source code
- `variables` (List[str]): Variables to check for conservation

**Returns:**
- `ConservationResult`: Conservation verification result

**Example:**
```python
result = judge.check_conservation(
    program,
    variables=["alice", "bob"]
)
print(f"Conservation holds: {result.is_conserved}")
print(f"Total before: {result.total_before}")
print(f"Total after: {result.total_after}")
```

## Data Classes

### JudgeConfig

Configuration for the Judge.

```python
@dataclass
class JudgeConfig:
    strict_mode: bool = True
    enable_proofs: bool = True
    enable_conservation: bool = True
    timeout: int = 30
    max_iterations: int = 1000
    optimization_level: int = 2
```

**Fields:**
- `strict_mode`: Enable strict verification (default: True)
- `enable_proofs`: Generate mathematical proofs (default: True)
- `enable_conservation`: Check conservation laws (default: True)
- `timeout`: Maximum verification time in seconds (default: 30)
- `max_iterations`: Maximum solver iterations (default: 1000)
- `optimization_level`: Optimization level 0-3 (default: 2)

### VerificationResult

Result of program verification.

```python
@dataclass
class VerificationResult:
    is_valid: bool
    proof: Optional[Proof]
    errors: List[VerificationError]
    warnings: List[str]
    execution_time: float
    metadata: Dict[str, Any]
```

**Fields:**
- `is_valid`: Whether the program is valid
- `proof`: Generated proof (if enabled)
- `errors`: List of verification errors
- `warnings`: List of warnings
- `execution_time`: Verification time in seconds
- `metadata`: Additional verification metadata

**Example:**
```python
result = judge.verify(program)

if result.is_valid:
    print(f"✓ Verified in {result.execution_time:.3f}s")
    if result.proof:
        print(f"Proof: {result.proof.summary}")
else:
    print("✗ Verification failed:")
    for error in result.errors:
        print(f"  Line {error.line}: {error.message}")
```

### Proof

Mathematical proof generated by the Judge.

```python
@dataclass
class Proof:
    theorem: str
    steps: List[ProofStep]
    conclusion: str
    is_valid: bool
    proof_type: str
    metadata: Dict[str, Any]
```

**Fields:**
- `theorem`: The theorem being proven
- `steps`: List of proof steps
- `conclusion`: Final conclusion
- `is_valid`: Whether the proof is valid
- `proof_type`: Type of proof (e.g., "conservation", "constraint")
- `metadata`: Additional proof metadata

**Example:**
```python
proof = result.proof

print(f"Theorem: {proof.theorem}")
print(f"Proof type: {proof.proof_type}")
print(f"\nSteps:")
for i, step in enumerate(proof.steps, 1):
    print(f"  {i}. {step.description}")
print(f"\nConclusion: {proof.conclusion}")
```

### ProofStep

Individual step in a proof.

```python
@dataclass
class ProofStep:
    step_number: int
    description: str
    justification: str
    formula: Optional[str]
```

**Fields:**
- `step_number`: Step number in the proof
- `description`: Human-readable description
- `justification`: Mathematical justification
- `formula`: Mathematical formula (if applicable)

### VerificationError

Error encountered during verification.

```python
@dataclass
class VerificationError:
    error_type: str
    message: str
    line: int
    column: int
    context: str
```

**Fields:**
- `error_type`: Type of error (e.g., "constraint_violation", "conservation_error")
- `message`: Error message
- `line`: Line number where error occurred
- `column`: Column number
- `context`: Surrounding code context

### ConservationResult

Result of conservation checking.

```python
@dataclass
class ConservationResult:
    is_conserved: bool
    total_before: float
    total_after: float
    difference: float
    variables: List[str]
    proof: Optional[Proof]
```

**Fields:**
- `is_conserved`: Whether conservation holds
- `total_before`: Total value before execution
- `total_after`: Total value after execution
- `difference`: Difference (should be 0)
- `variables`: Variables checked
- `proof`: Conservation proof

## Complete Example

```python
from diotec360.core.judge import Judge, JudgeConfig

# Configure Judge
config = JudgeConfig(
    strict_mode=True,
    enable_proofs=True,
    timeout=30
)

# Create Judge instance
judge = Judge(config)

# Aethel program
program = """
solve banking_transfer {
    # Initial balances
    checking = 5000
    savings = 10000
    
    # Transfer parameters
    transfer_amount = 1000
    
    # Constraints
    assert transfer_amount > 0
    assert transfer_amount <= checking
    
    # Execute transfer
    checking = checking - transfer_amount
    savings = savings + transfer_amount
    
    # Conservation law
    conserve checking + savings == 15000
}
"""

# Verify program
result = judge.verify(program)

# Check result
if result.is_valid:
    print("✓ Program verified successfully")
    print(f"Verification time: {result.execution_time:.3f}s")
    
    # Display proof
    if result.proof:
        print(f"\nProof:")
        print(f"  Theorem: {result.proof.theorem}")
        print(f"  Steps: {len(result.proof.steps)}")
        print(f"  Conclusion: {result.proof.conclusion}")
    
    # Check for warnings
    if result.warnings:
        print(f"\nWarnings:")
        for warning in result.warnings:
            print(f"  - {warning}")
else:
    print("✗ Verification failed")
    for error in result.errors:
        print(f"  Line {error.line}: {error.message}")

# Check conservation specifically
conservation = judge.check_conservation(
    program,
    variables=["checking", "savings"]
)

print(f"\nConservation check:")
print(f"  Conserved: {conservation.is_conserved}")
print(f"  Total before: {conservation.total_before}")
print(f"  Total after: {conservation.total_after}")
print(f"  Difference: {conservation.difference}")
```

## Error Handling

```python
from diotec360.core.judge import Judge, JudgeError

judge = Judge()

try:
    result = judge.verify(program)
except JudgeError as e:
    print(f"Judge error: {e}")
except TimeoutError:
    print("Verification timed out")
except Exception as e:
    print(f"Unexpected error: {e}")
```

## Performance Tips

### 1. Reuse Judge Instances

```python
# Good: Reuse judge
judge = Judge()
for program in programs:
    result = judge.verify(program)

# Bad: Create new judge each time
for program in programs:
    judge = Judge()  # Expensive!
    result = judge.verify(program)
```

### 2. Disable Proofs for Performance

```python
# For high-throughput scenarios
config = JudgeConfig(enable_proofs=False)
judge = Judge(config)
```

### 3. Set Appropriate Timeouts

```python
# For simple programs
config = JudgeConfig(timeout=5)

# For complex programs
config = JudgeConfig(timeout=60)
```

## See Also

- [Runtime API](runtime.md)
- [Conservation Validator API](conservation-validator.md)
- [Language Reference](../language-reference/syntax.md)
- [Examples](../examples/banking.md)
